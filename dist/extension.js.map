{"version":3,"file":"extension.js","mappings":"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","sources":["../webpack/bootstrap","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../external node-commonjs \"path\"","../external commonjs \"vscode\"",".././src/core/services/barrel-content.builder.ts",".././src/core/services/export.parser.ts","../external node-commonjs \"fs/promises\"",".././src/core/services/file-system.service.ts",".././src/core/services/barrel-file.generator.ts",".././src/extension.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"path\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"vscode\");","const DEFAULT_KEYWORD = 'default';\nconst NEWLINE = '\\n';\nconst PARENT_DIRECTORY = '..';\nexport class BarrelContentBuilder {\n    buildContent(entries, _directoryPath) {\n        const lines = [];\n        const normalizedEntries = this.normalizeEntries(entries);\n        const sortedPaths = Array.from(normalizedEntries.keys()).sort();\n        for (const relativePath of sortedPaths) {\n            const entry = normalizedEntries.get(relativePath);\n            if (!entry) {\n                continue;\n            }\n            const exportLines = this.createLinesForEntry(relativePath, entry);\n            if (exportLines.length > 0) {\n                lines.push(...exportLines);\n            }\n        }\n        return lines.join(NEWLINE) + NEWLINE;\n    }\n    normalizeEntries(entries) {\n        const normalized = new Map();\n        for (const [relativePath, entry] of entries) {\n            if (Array.isArray(entry)) {\n                normalized.set(relativePath, { kind: 'file', exports: entry });\n            }\n            else {\n                normalized.set(relativePath, entry);\n            }\n        }\n        return normalized;\n    }\n    createLinesForEntry(relativePath, entry) {\n        if (entry.kind === 'directory') {\n            return this.buildDirectoryExportLines(relativePath);\n        }\n        return this.buildFileExportLines(relativePath, entry.exports);\n    }\n    buildDirectoryExportLines(relativePath) {\n        const modulePath = this.getModulePath(relativePath);\n        if (modulePath.startsWith(PARENT_DIRECTORY)) {\n            return [];\n        }\n        return [`export * from './${modulePath}';`];\n    }\n    buildFileExportLines(filePath, exports) {\n        const cleanedExports = exports.filter((exp) => !exp.includes(PARENT_DIRECTORY));\n        if (cleanedExports.length === 0) {\n            return [];\n        }\n        const modulePath = this.getModulePath(filePath);\n        if (modulePath.startsWith(PARENT_DIRECTORY)) {\n            return [];\n        }\n        return this.generateExportStatements(modulePath, cleanedExports);\n    }\n    generateExportStatements(modulePath, exports) {\n        const hasDefaultExport = exports.includes(DEFAULT_KEYWORD);\n        const hasNamedExports = exports.some((exp) => exp !== DEFAULT_KEYWORD);\n        if (hasDefaultExport && !hasNamedExports) {\n            return [`export { default } from './${modulePath}';`];\n        }\n        const lines = [];\n        if (hasNamedExports) {\n            const namedExports = exports.filter((exp) => exp !== DEFAULT_KEYWORD);\n            lines.push(`export { ${namedExports.join(', ')} } from './${modulePath}';`);\n        }\n        if (hasDefaultExport) {\n            lines.push(`export { default } from './${modulePath}';`);\n        }\n        return lines;\n    }\n    getModulePath(filePath) {\n        let modulePath = filePath.replace(/\\.tsx?$/, '');\n        modulePath = modulePath.replace(/\\\\/g, '/');\n        return modulePath;\n    }\n}\n","export class ExportParser {\n    extractExports(content) {\n        const exports = [];\n        const contentWithoutComments = this.removeComments(content);\n        const namedExportPattern = /export\\s+(?:abstract\\s+)?(?:class|interface|type|function|const|enum|let|var)\\s+([A-Za-z_$][A-Za-z0-9_$]*)/g;\n        let match;\n        while ((match = namedExportPattern.exec(contentWithoutComments)) !== null) {\n            exports.push(match[1]);\n        }\n        const exportListPattern = /export\\s*\\{([^}]+)\\}/g;\n        while ((match = exportListPattern.exec(contentWithoutComments)) !== null) {\n            const names = match[1]\n                .split(',')\n                .map((name) => name\n                .trim()\n                .split(/\\s+as\\s+/i)\n                .map((segment) => segment.trim())\n                .filter((segment) => segment.length > 0)\n                .pop() ?? '')\n                .filter((name) => name.length > 0);\n            exports.push(...names);\n        }\n        if (/export\\s+default\\s+/.test(contentWithoutComments)) {\n            exports.push('default');\n        }\n        return [...new Set(exports)];\n    }\n    removeComments(content) {\n        let result = content.replace(/\\/\\*[\\s\\S]*?\\*\\//g, '');\n        result = result.replace(/\\/\\/.*$/gm, '');\n        return result;\n    }\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"fs/promises\");","import * as fs from 'fs/promises';\nimport * as path from 'path';\nconst INDEX_FILE_NAME = 'index.ts';\nconst IGNORED_DIRECTORIES = new Set(['node_modules', '.git']);\nexport class FileSystemService {\n    async getTypeScriptFiles(directoryPath) {\n        const entries = await this.readDirectory(directoryPath);\n        return entries\n            .filter((entry) => this.isTypeScriptFile(entry))\n            .map((entry) => path.join(directoryPath, entry.name));\n    }\n    async getSubdirectories(directoryPath) {\n        const entries = await this.readDirectory(directoryPath);\n        return entries\n            .filter((entry) => this.isTraversableDirectory(entry))\n            .map((entry) => path.join(directoryPath, entry.name));\n    }\n    isTypeScriptFile(entry) {\n        if (!entry.isFile()) {\n            return false;\n        }\n        const isIndexFile = entry.name === INDEX_FILE_NAME;\n        const isDefinitionFile = entry.name.endsWith('.d.ts');\n        const isTsFile = entry.name.endsWith('.ts') || entry.name.endsWith('.tsx');\n        return isTsFile && !isIndexFile && !isDefinitionFile;\n    }\n    isTraversableDirectory(entry) {\n        return (entry.isDirectory() && !IGNORED_DIRECTORIES.has(entry.name) && !entry.name.startsWith('.'));\n    }\n    async readFile(filePath) {\n        try {\n            return await fs.readFile(filePath, 'utf-8');\n        }\n        catch (error) {\n            throw new Error(`Failed to read file ${filePath}: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n    async writeFile(filePath, content) {\n        try {\n            await fs.writeFile(filePath, content, 'utf-8');\n        }\n        catch (error) {\n            throw new Error(`Failed to write file ${filePath}: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n    async fileExists(filePath) {\n        try {\n            await fs.access(filePath);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    async readDirectory(directoryPath) {\n        try {\n            return await fs.readdir(directoryPath, { withFileTypes: true });\n        }\n        catch (error) {\n            throw new Error(`Failed to read directory: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n}\n","import * as path from 'path';\nimport { BarrelContentBuilder } from './barrel-content.builder';\nimport { ExportParser } from './export.parser';\nimport { FileSystemService } from './file-system.service';\nconst INDEX_FILE_NAME = 'index.ts';\nexport class BarrelFileGenerator {\n    fileSystemService;\n    exportParser;\n    barrelContentBuilder;\n    constructor(fileSystemService, exportParser, barrelContentBuilder) {\n        this.fileSystemService = fileSystemService || new FileSystemService();\n        this.exportParser = exportParser || new ExportParser();\n        this.barrelContentBuilder = barrelContentBuilder || new BarrelContentBuilder();\n    }\n    async generateBarrelFile(directoryUri, options) {\n        const normalizedOptions = this.normalizeOptions(options);\n        await this.generateBarrelFileFromPath(directoryUri.fsPath, normalizedOptions);\n    }\n    async generateBarrelFileFromPath(directoryPath, options) {\n        const barrelFilePath = path.join(directoryPath, INDEX_FILE_NAME);\n        const { tsFiles, subdirectories } = await this.readDirectoryInfo(directoryPath);\n        if (options.recursive) {\n            await this.processChildDirectories(subdirectories, options);\n        }\n        const entries = await this.collectEntries(directoryPath, tsFiles, subdirectories);\n        const hasExistingIndex = await this.fileSystemService.fileExists(barrelFilePath);\n        if (!this.shouldWriteBarrel(entries, options, hasExistingIndex)) {\n            return;\n        }\n        const barrelContent = this.barrelContentBuilder.buildContent(entries, directoryPath);\n        await this.fileSystemService.writeFile(barrelFilePath, barrelContent);\n    }\n    async readDirectoryInfo(directoryPath) {\n        const [tsFiles, subdirectories] = await Promise.all([\n            this.fileSystemService.getTypeScriptFiles(directoryPath),\n            this.fileSystemService.getSubdirectories(directoryPath),\n        ]);\n        return { tsFiles, subdirectories };\n    }\n    async processChildDirectories(subdirectories, options) {\n        for (const subdirectoryPath of subdirectories) {\n            if (options.mode === 'updateExisting' &&\n                !(await this.fileSystemService.fileExists(path.join(subdirectoryPath, INDEX_FILE_NAME)))) {\n                continue;\n            }\n            await this.generateBarrelFileFromPath(subdirectoryPath, options);\n        }\n    }\n    async collectEntries(directoryPath, tsFiles, subdirectories) {\n        const entries = new Map();\n        await this.addFileEntries(directoryPath, tsFiles, entries);\n        await this.addSubdirectoryEntries(directoryPath, subdirectories, entries);\n        return entries;\n    }\n    async addFileEntries(directoryPath, tsFiles, entries) {\n        for (const filePath of tsFiles) {\n            const content = await this.fileSystemService.readFile(filePath);\n            const exports = this.exportParser.extractExports(content);\n            if (exports.length === 0) {\n                continue;\n            }\n            const relativePath = path.relative(directoryPath, filePath);\n            entries.set(relativePath, { kind: 'file', exports });\n        }\n    }\n    async addSubdirectoryEntries(directoryPath, subdirectories, entries) {\n        for (const subdirectoryPath of subdirectories) {\n            const barrelPath = path.join(subdirectoryPath, INDEX_FILE_NAME);\n            if (!(await this.fileSystemService.fileExists(barrelPath))) {\n                continue;\n            }\n            const relativePath = path.relative(directoryPath, subdirectoryPath);\n            entries.set(relativePath, { kind: 'directory' });\n        }\n    }\n    shouldWriteBarrel(entries, options, hasExistingIndex) {\n        if (entries.size > 0) {\n            return true;\n        }\n        if (options.mode === 'updateExisting') {\n            return hasExistingIndex;\n        }\n        if (!options.recursive) {\n            throw new Error('No TypeScript files found in the selected directory');\n        }\n        return hasExistingIndex;\n    }\n    normalizeOptions(options) {\n        return {\n            recursive: options?.recursive ?? false,\n            mode: options?.mode ?? 'createOrUpdate',\n        };\n    }\n}\n","import * as path from 'path';\nimport * as vscode from 'vscode';\nimport { BarrelFileGenerator, } from './core/services/barrel-file.generator';\nexport function activate(context) {\n    console.log('Barrel Roll extension is now active');\n    const generator = new BarrelFileGenerator();\n    const descriptors = [\n        {\n            id: 'barrel-roll.generateBarrel',\n            options: { recursive: false, mode: 'createOrUpdate' },\n            progressTitle: 'Barrel Roll: Generating barrel...',\n            successMessage: 'Barrel Roll: barrel file generated successfully.',\n        },\n        {\n            id: 'barrel-roll.generateBarrelRecursive',\n            options: { recursive: true, mode: 'createOrUpdate' },\n            progressTitle: 'Barrel Roll: Generating barrels recursively...',\n            successMessage: 'Barrel Roll: barrel files generated recursively.',\n        },\n        {\n            id: 'barrel-roll.updateBarrel',\n            options: { recursive: true, mode: 'updateExisting' },\n            progressTitle: 'Barrel Roll: Updating barrels...',\n            successMessage: 'Barrel Roll: barrel files sanitized successfully.',\n        },\n    ];\n    for (const descriptor of descriptors) {\n        const disposable = registerBarrelCommand(generator, descriptor);\n        context.subscriptions.push(disposable);\n    }\n}\nexport function deactivate() { }\nfunction registerBarrelCommand(generator, descriptor) {\n    return vscode.commands.registerCommand(descriptor.id, async (uri) => {\n        try {\n            const targetDirectory = await resolveTargetDirectory(uri);\n            if (!targetDirectory) {\n                return;\n            }\n            await withProgress(descriptor.progressTitle, async () => {\n                await generator.generateBarrelFile(targetDirectory, descriptor.options);\n            });\n            vscode.window.showInformationMessage(descriptor.successMessage);\n        }\n        catch (error) {\n            const message = error instanceof Error ? error.message : String(error);\n            vscode.window.showErrorMessage(`Barrel Roll: ${message}`);\n        }\n    });\n}\nasync function resolveTargetDirectory(uri) {\n    const initial = uri ?? (await promptForDirectory());\n    if (!initial) {\n        return undefined;\n    }\n    return ensureDirectoryUri(initial);\n}\nasync function promptForDirectory() {\n    const selected = await vscode.window.showOpenDialog({\n        canSelectFiles: false,\n        canSelectFolders: true,\n        canSelectMany: false,\n        openLabel: 'Select folder to barrel',\n    });\n    if (!selected || selected.length === 0) {\n        return undefined;\n    }\n    return selected[0];\n}\nasync function ensureDirectoryUri(uri) {\n    try {\n        const stat = await vscode.workspace.fs.stat(uri);\n        if (stat.type === vscode.FileType.Directory) {\n            return uri;\n        }\n        if (stat.type === vscode.FileType.File) {\n            return vscode.Uri.file(path.dirname(uri.fsPath));\n        }\n    }\n    catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        throw new Error(`Unable to access selected resource: ${message}`);\n    }\n    return uri;\n}\nasync function withProgress(title, task) {\n    return vscode.window.withProgress({\n        location: vscode.ProgressLocation.Window,\n        title,\n    }, task);\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","require","DEFAULT_KEYWORD","PARENT_DIRECTORY","BarrelContentBuilder","buildContent","entries","_directoryPath","lines","normalizedEntries","this","normalizeEntries","sortedPaths","Array","from","keys","sort","relativePath","entry","exportLines","createLinesForEntry","length","push","join","normalized","Map","isArray","set","kind","buildDirectoryExportLines","buildFileExportLines","modulePath","getModulePath","startsWith","filePath","cleanedExports","filter","exp","includes","generateExportStatements","hasDefaultExport","hasNamedExports","some","namedExports","replace","ExportParser","extractExports","content","contentWithoutComments","removeComments","namedExportPattern","match","exec","exportListPattern","names","split","map","name","trim","segment","pop","test","Set","result","IGNORED_DIRECTORIES","FileSystemService","getTypeScriptFiles","directoryPath","readDirectory","isTypeScriptFile","getSubdirectories","isTraversableDirectory","isFile","isIndexFile","isDefinitionFile","endsWith","isDirectory","has","readFile","error","Error","message","String","writeFile","fileExists","withFileTypes","BarrelFileGenerator","fileSystemService","exportParser","barrelContentBuilder","constructor","generateBarrelFile","directoryUri","options","normalizedOptions","normalizeOptions","generateBarrelFileFromPath","fsPath","barrelFilePath","tsFiles","subdirectories","readDirectoryInfo","recursive","processChildDirectories","collectEntries","hasExistingIndex","shouldWriteBarrel","barrelContent","Promise","all","subdirectoryPath","mode","addFileEntries","addSubdirectoryEntries","barrelPath","size","activate","context","console","log","generator","descriptors","id","progressTitle","successMessage","descriptor","disposable","registerBarrelCommand","subscriptions","deactivate","registerCommand","async","uri","targetDirectory","initial","selected","showOpenDialog","canSelectFiles","canSelectFolders","canSelectMany","openLabel","promptForDirectory","stat","fs","type","Directory","File","file","ensureDirectoryUri","resolveTargetDirectory","title","withProgress","location","Window","showInformationMessage","showErrorMessage"],"sourceRoot":""}